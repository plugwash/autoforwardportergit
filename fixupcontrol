#!/usr/bin/python3
#(C) 2017 Peter Michael Green <plugwash@debian.org>
#This software is provided 'as-is', without any express or implied warranty. In
#no event will the authors be held liable for any damages arising from the use
#of this software.
#
#Permission is granted to anyone to use this software for any purpose, including
#commercial applications, and to alter it and redistribute it freely, subject to
#the following restrictions:
#
#1. The origin of this software must not be misrepresented; you must not claim.
#that you wrote the original software. If you use this software in a product,
#an acknowledgment in the product documentation would be appreciated but is.
#not required.
#
#2. Altered source versions must be plainly marked as such, and must not be
#misrepresented as being the original software.
#
#3. This notice may not be removed or altered from any source distribution.

import sys
import re
import subprocess
import collections
from difflib import SequenceMatcher
from afpg_util import mergelists

filetofix = sys.argv[1]
tempdir = sys.argv[2]

f = open(filetofix,'rb')
lines = f.readlines()
f.close()

ld = []
lm = []
lu = []
fd = open(tempdir+'/dtmp','wb')
fm = open(tempdir+'/mtmp','wb')
fu = open(tempdir+'/utmp','wb')


mode = 0; # 0: unconflicted text 1: downstream text 2: mergehead text 3: upstream text

downstream = set()
mergehead = set()
upstream = set()
deferred = []

def writesplitline(f,line):
	hasnewline = False
	if line[-1:] == b"\n":
		line = line[:-1]
		hasnewline = True
	#print(repr(line[-1:]))
	linesplit = re.match(rb'^(\s*[^\s]*)(.*)$',line).groups()
	
	f.write(b'[1]'+linesplit[0]+b"\n")
	f.write(b'[2]'+linesplit[1]+b"\n")
	if hasnewline:
		f.write(b'[3]'+linesplit[0]+b"\n")
	else:
		f.write(b'[3]'+linesplit[0])

#for stage in range(0,2):
for line in lines:
		#print(repr(line))
		if (line.startswith(b'<<<<<<< ')):
			if (mode == 0):
				mode = 1
				#print('found <<<<<<< switching to mode 1')
			else:
				print('broken diff3, unexpected <<<<<<<', file=sys.stderr)
				sys.exit(1);
		elif (line.startswith(b'||||||| ')):
			if (mode == 1):
				mode = 2
				#print('found ||||||| switching to mode 2')
			else:
				print('broken diff3, unexpected |||||||', file=sys.stderr)
				sys.exit(1);
		elif (line == b'=======\n'):
			if (mode == 2):
				mode = 3
				#print('found ======= switching to mode 3')
			else:
				print('broken diff3, unexpected =======', file=sys.stderr)
				sys.exit(1);
		elif (line.startswith(b'>>>>>>> ')):
			if (mode == 3):
				#print('found >>>>>>> switching to mode 0')
				mode = 0
			else:
				print('broken diff3, unexpected >>>>>>>', file=sys.stderr)
				sys.exit(1);
		else:
			if ((mode == 0) or (mode == 1)):
				ld.append(line)
			if ((mode == 0) or (mode == 2)):
				lm.append(line)
			if ((mode == 0) or (mode == 3)):
				lu.append(line)


def trymerge(ld,lm,lu):
	fd = open(tempdir+'/dtmp','wb')
	fm = open(tempdir+'/mtmp','wb')
	fu = open(tempdir+'/utmp','wb')
	
	for line in ld:
		writesplitline(fd,line)
	
	for line in lm:
		writesplitline(fm,line)
	
	for line in lu:
		writesplitline(fu,line)
	
	fd.close()
	fm.close()
	fu.close()

	command = ['merge',tempdir+'/dtmp',tempdir+'/mtmp',tempdir+'/utmp']
	print(command, flush=True)
	return subprocess.call(command)

def splitonbuilddeps(lines):
	bbd = []
	bd = []
	abd = []
	mode = 0;
	for line in lines:
		if (mode == 0):
			if line.startswith(b'Build-Depends:'):
				mode = 1
				bd.append(line)
			else:
				bbd.append(line)
		elif (mode == 1):
			if (line.startswith(b' ') or line.startswith(b"\t")) and not line.isspace():
				bd.append(line)
			else:
				mode = 2
				abd.append(line)
		else:
			abd.append(line)
	if mode != 2:
		print('failed to split build-depends from rest of control content')
		sys.exit(1);
	return (bbd,bd,abd)

def parsebuilddeps(lines):
	text = lines[0][14:] + b''.join(lines[1:])
	builddeplist = text.split(b',')
	builddepdict = collections.OrderedDict()
	for builddepraw in builddeplist:
		builddep = builddepraw.strip()
		p = builddepraw.find(builddep)
		whitespacebefore = builddepraw[:p]
		whitespaceafter = builddepraw[p+len(builddep):]
		#print(repr(whitespacebefore)+' '+repr(builddep)+' '+repr(whitespaceafter))
		#print(builddep)
		match = re.match(b'[a-zA-Z0-9+-.]*',builddep)
		#print(repr(match.span()))
		#sys.exit(1)
		splitpos = match.span()[1]
		dep = builddep[:splitpos]
		meta = builddep[splitpos:]
		#print((dep,meta))
		#sys.exit(1)
		#split = re.split(b'[^a-zA-Z0-9+-.]',builddep,1)
		#if len(split) == 2:
		#	(dep,meta) = split
		#else:
		#	dep = builddep
		#	meta = b''
		if dep in builddepdict:
			builddepdict[dep].append((meta,whitespacebefore,whitespaceafter))
		else:
			builddepdict[dep] = [(meta,whitespacebefore,whitespaceafter)]
	#for line in builddepdict.items():
	#	print(line)
	#sys.exit(1)
	return builddepdict

if (trymerge(ld,lm,lu) != 0): 
	print('merge of processed files failed, trying plan B build-dep fixer')
	
	(ldbbd , ldbd , ldabd) = splitonbuilddeps(ld)
	(lmbbd , lmbd , lmabd) = splitonbuilddeps(lm)
	(lubbd , lubd , luabd) = splitonbuilddeps(lu)
	
	spacecount = 1;
	if len(lubd) >= 2:
		#print(lubd[1][spacecount])
		#note: in python3 indexing a string produces a string
		#but indexing a "bytes" produces a number
		while lubd[1][spacecount] == b' '[0]:
			spacecount += 1
	
	#for line in ldbd:
	#	print(line)
	#pase build-depends into dictionaries
	ddbd = parsebuilddeps(ldbd)
	dmbd = parsebuilddeps(lmbd)
	dubd = parsebuilddeps(lubd)
	
	#extract sets from dictionaries.
	sdbd = set(ddbd.keys())
	smbd = set(dmbd.keys())
	subd = set(dubd.keys())

	dsadded = sdbd - smbd
	dsremoved = smbd - sdbd
	usadded = subd - smbd
	usremoved = smbd - subd
	#print(dsadded)
	#print(dsremoved)
	#print(usadded)
	#print(usremoved)

	#sys.exit(1)

	finalset = smbd | usadded | dsadded - usremoved - dsremoved

	final = collections.OrderedDict()
	#for dep in dubd:
	#	final[dep] = 1;
	#for dep in ddbd:
	#	final[dep] = 1;
	for dep in mergelists(list(dubd.keys()),b = list(ddbd.keys())):
		#print(dep)
		if dep not in ddbd:
			final[dep] = dubd[dep]
		elif dep not in dubd:
			final[dep] = ddbd[dep]
		elif set(p[0] for p in dubd[dep]) == set(p[0] for p in ddbd[dep]):
			final[dep] = dubd[dep]
		else:
			#print(repr(dubd[dep]))
			#print(repr(dubd[dep][0]))
			print('upstream and downstream have dependency on '+dep.decode('ascii')+' with different metadata, this is currently unhandled, upstream metadata is '+list(p[0] for p in dubd[dep])+' downstream metadata is '+list(p[0] for p in ddbd[dep]))
			exit(1)
	firstdep = True
	regeneratedbuilddeps = []
	#print(repr(final))
	queued = ''
	for (dep,meta) in final.items():
		for (metaentry,whitespacebefore,whitespaceafter) in meta:
			if firstdep:
				line = b'Build-Depends:'
				firstdep = False
			else:
				line = b'';
				regeneratedbuilddeps[-1] += queued
			#print(repr(dep)+' '+repr(metaentry))
			line += whitespacebefore + dep + metaentry
			#we don't want to add this stuff for the last line, so queue it here and
			#add it on the next iteration
			queued =  whitespaceafter+ b','
			regeneratedbuilddeps.append(line)
	#make sure end of lines in list match up with newlines and add final newline
	regeneratedbuilddeps = list(line+b'\n' for line in b''.join(regeneratedbuilddeps).split(b'\n'))

	ld = ldbbd + regeneratedbuilddeps + ldabd
	lm = lmbbd + regeneratedbuilddeps + lmabd
	lu = lubbd + regeneratedbuilddeps + luabd


	#usadded 

	if (trymerge(ld,lm,lu) != 0): 
		
		print('merge of processed files failed, after plan B build-dep fixer, giving up')
		sys.exit(1)

fd = open(tempdir+'/dtmp','rb')

l1 = b''
l2 = b''
l3 = b''

f = open(filetofix+'.new','wb')

for line in fd:
	hasnewline = False
	if line[-1:] == b"\n":
		line = line[:-1]
		hasnewline = True
	if line[:3] == b'[1]':
		l1 = line[3:]
	elif line[:3] == b'[2]':
		l2 = line[3:]
	elif line[:3] == b'[3]':
		l3 = line[3:]
		if (l1 != l3):
			print('l1 and l3 do not match in merge result')
			sys.exit(1)
		output = l1 + l2
		if hasnewline:
			output += b'\n';
		f.write(output)
	else:
		print('unexpected line in merge result')
		sys.exit(1)

f.close

command = ['mv',filetofix+'.new',filetofix]
print(command, flush=True)
if (subprocess.call(command) != 0): 
    print('moviing result into place failed')
    sys.exit(1)
